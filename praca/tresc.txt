\documentclass{article}

\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[polish]{babel}
\usepackage{indentfirst}
\usepackage{float}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{tikz,fullpage}
\usetikzlibrary{arrows,%
                petri,%
                topaths,%
                positioning,%
                }
\usepackage{tkz-berge}
\usepackage[position=top]{subfig}

\title{Projekt dyplomowy in¿ynierski \\ Gra survival-RPG w Unity 3D\\ The Mighty Marian - genrowanie proceduralne}
\author{Krzysztof Jasiak, 137298 \\ Tobiasz Biernacki, 137249 \\ Dominika Soko³owska, 138635}
\date{04.11.2014}

\begin{document}

\maketitle

\section{Generowanie proceduralne grach}
\subsection{Geneza}
\subsection{Najczêstrze algorytmy}
\subsection{Przyk³adowe zastosowania}


\section{Generowanie map w grze The Mighty Marian}
W naszym projekcie ka¿da rozgrywka polega na przejœciu kilku, dziesiêciu do pietnastu, poziomów jaskiñ. Ka¿da z jaskiñ generowana jest niezale¿nie, przy u¿yciu algorytmu stworzonego na potrzeby projektu. Generowany obszar, pomimo tego, ¿e w grze wizualnie reprezentowany jest w trzech wymiarach, na etapie generacji traktujemy jako dwuwymiarowy. Mapa sk³ada siê z p³ytek, zwanych tak¿e komórkami, które mog¹ przyjmowaæ dwie wartoœci, s¹ \textbf{pod³og¹} lub \textbf{nicoœci¹}. Bohater i wrogowie mog¹ przebywaæ i poruszaæ siê jedynie po komórkach pod³ogi.\\
Komórki pod³ogi na rysunkach reprezentowane bêd¹ przez jaœniejsze pola, natomiast komórki, po których postacie nie mog¹ siê poruszaæ, kolorem ciemnym.

\subsection{Poprawnoœæ mapy}
Celem algorytmu jest wygenerowanie mapy, która bêd¹c wystarczaj¹co skomplikowan¹, aby gracz móg³ siê w niej zgubiæ i jednoczeœnie spójn¹, tak, aby wszystkie komórki pod³ogi, z których sk³ada siê mapa by³y osi¹galne przez gracza. Drugi warunek jest konieczny do spe³nienia, poniewa¿ gdyby postaæ Mariana i drabina umo¿liwiaj¹ca przejœcie miêdzy poziomami gry zosta³y umieszczone w innych "sk³adowych spójnoœci" mapy, to skoñczenie gry by³oby niemo¿liwe. \\~\\
To, czy mapa jest spójna (nie istniej¹ w niej komórki pod³ogi, do których nie da siê dotrzeæ z ka¿dej innej komórki pod³ogi) da siê stosunkowo prosto sprawdziæ algorytmicznie, to okreœlenie stopnia skomplikowania i zawi³oœci korytarzy jest ju¿ zadaniem, którego w ramach tego projektu nie podjeliœmy siê zrealizowaæ. Zdecydowaliœmy siê okreœlaæ w pocz¹tkowym etapie skomplikowane korytarze i traktowaæ je jako formê, na której dzia³aj¹ kolejne kroki algorytmu. Daje nam to gwarancjê mapy o porz¹danym poziomie skomplikowania i podzielonej na logiczne obszary. Ten proces zostanie dok³adniej opisany w dalszej czêœci dokumentu.

\subsection{Automat komórkowy - gra w ¿ycie}
W projekcie The Mighty Marian do generowania map zosta³ u¿yty automat komórkowy. Automat komórkowy o odpowiednich parametrach i kryteriach prze¿ycia komórek pozwala w niewielu krokach wygenerowaæ ciekawe struktury podobne do jaskiñ. Niestety to rozwi¹zanie ma równie¿ swoje ograniczenia.\\~\\
Automat komórkowy to model matematyczny, w którym komórki znajduj¹ siê w jednym z okreœlonych stanów. System sk³ada siê z pojedyñczych komórek, znajduj¹cych siê obok siebie. Ka¿da z komórek mo¿e przyj¹æ jeden ze stanów, przy czym liczba stanów jest skoñczona. Plansza, na której znajduj¹ siê komórki mo¿e byæ w dowolnej skoñczonej liczbie wymiarów.\\
Inicjalnie, w czasie $t = 0$, ka¿da z komórek znajduje siê w jednym z mo¿liwych stanów. Ich stan w czasie $t = 1$, nowa generacja komórek, okreœlona jest pewn¹ funkcj¹ matematyczn¹, zwykle zale¿n¹ od stanu jej s¹siadek.\\
Na potrzeby tej pracy rozpatrywaæ bêdziemy automaty komórkowe w dwóch wymiarach, w których komórki mog¹ przyj¹æ jeden z dwóch stanów, $\{ ¿ywa,martwa\}$. Oczywiœcie automaty komórkowe maj¹ o wiele wiêcej mo¿liwych zastosowañ i mo¿liwoœci, s¹ u¿ywane chocia¿by przy symulowaniu ewolucji czy proceduralnym generowaniu tekstur.

\begin{figure}[H]
\centering
\begin{minipage}{.48\textwidth}
\centering
\includegraphics[width=\linewidth]{it7.png}
\caption{Spójna mapa o niewielkim poziomie skomplikowania. Otwarty pokój, gdzie gracz nie bêdzie mia³ czego odkrywaæ}
\label{fig:test1}
\end{minipage}\hfill
\begin{minipage}{.48\textwidth}
\centering
\includegraphics[width=\linewidth]{kotel.jpg}
\caption{Mapa niespójna, ale ciekawa pod wzglêdem grywalnoœci}
\label{fig:test2}
\end{minipage}\hfill
\end{figure}


\subsection{Etapy procesu generowania mapy}
Proces powstawania map mo¿na podzieliæ na piêæ etapów. Produkt koñcowy ka¿dego z etapów jest danymi wejœciowymi dla kolejnego etapu.
\subsubsection{Etap labiryntu}
Proces generowania mapy rozpoczyna siê od stworzenia labiryntu, który okreœli czy pomiêdzy wybranymi pokojami wystêpuje po³¹czenie.\\Parametry startowe algorytmu w pierwszej fazie s¹ nastêpuj¹ce:\\
$Rooms X$, $Rooms Y$ - iloœæ pokojów, na które dzielimy przestrzeñ mapy\\
Na tym etapie mapê modelujemy za pomoc¹ grafu prostego wa¿onego w nastêpuj¹cy sposób:\\
$G(V,E)$ - graf nieskierowany\\
$V$ - zbiór wierzcho³ków - pojedyñczy wierzcho³ek reprezentuje jeden pokój $|V|= Rooms X * Rooms Y$\\
$E$ - zbiór krawêdzi - krawêdŸ reprezenuje przejœcie miêdzy pokojami\\~\\
Program generuje pocz¹tkowy graf przejœæ miêdzy pokojami. Inicjalnie wszystkie mo¿liwe przejœcia miêdzy s¹siednimi pokojami istniej¹.

\begin{figure}[H]
\centering
\begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=1.7cm,
  thick,main node/.style={circle,fill=white!25,draw,minimum size = 8mm}]
  \node[main node] (0) {0};
  \node[main node] (1) [right of=0]{1};
  \node[main node] (2) [right of=1]{2};
  \node[main node] (3) [right of=2]{3};
  \node[main node] (4) [below of=0]{4};
  \node[main node] (5) [right of=4]{5};
  \node[main node] (6) [right of=5]{6};
  \node[main node] (7) [right of=6]{7};
  \node[main node] (8) [below of=4]{8};
  \node[main node] (9) [right of=8]{9};
  \node[main node] (10) [right of=9]{10};
  \node[main node] (11) [right of=10]{11};
  \node[main node] (12) [below of=8]{12};
  \node[main node] (13) [right of=12]{13};
  \node[main node] (14) [right of=13]{14};
  \node[main node] (15) [right of=14]{15};
  \path[every node/.style={font=\sffamily\small}]
     (0) edge node [left] {} (1)
         edge node [below] {} (4)
     (1) edge node [left] {} (2)
         edge node [below] {} (5)
     (2) edge node [left] {} (3)
         edge node [below] {} (6)
     (3) edge node [below] {} (7)         
     (4) edge node [left] {} (5)
         edge node [below] {} (8)
     (5) edge node [left] {} (6)
         edge node [below] {} (9)
     (6) edge node [left] {} (7)
         edge node [below] {} (10)
     (7) edge node [below] {} (11)  
     (8) edge node [left] {} (9)
         edge node [below] {} (12)
     (9) edge node [left] {} (10)
         edge node [below] {} (13)
     (10) edge node [left] {} (11)
         edge node [below] {} (14)
     (11) edge node [below] {} (15)
     (12) edge node [left] {} (13)
     (13) edge node [left] {} (14)
     (14) edge node [left] {} (15);

\end{tikzpicture}
\caption{Pocz¹tkowy graf po³¹czeñ miêdzy pokojami dla $Rooms X = Rooms Y = 4$}
\end{figure}
W tak zamodelowanej przestrzeni wygenerowanie labiryntu ³¹cz¹cego pokoje sprowadza siê do znalezienia \textbf{minimalnego drzewa spinaj¹cego} w grafie $G$. Drzewo spinaj¹ce grafu jest grafem spójnym i acyklicznym, który zawiera wszystkie wierzcho³ki grafu oraz niektóre z jego krawêdzi. Minimalne drzewo spinaj¹ce jest drzewem spinaj¹cym, którego suma wag krawêdzi jest najmniejsza ze wszystkich pozosta³ych drzew rozpinaj¹cych danego grafu.. W danym grafie mo¿e istnieæ mo¿e istnieæ wiêcej ni¿ jedno drzewo o tych w³asnoœciach. Z punktu widzenia grywalnoœci nie ma znaczenia które wybierzemy, zatem wystarczy wskazaæ jedno z nich, a wagi krawêdziom grafu mo¿emy przypisaæ losowo. Do uskania minimalnego drzewa spinaj¹cego zosta³ u¿yty zosta³ algrytm Prima, wybrany ze wzglêdu na ³atwoœæ implementacji.\\
Krawêdziom grafu $G$ przyporz¹dokwane zostaj¹ losowe wagi z zakresu $(3,660)$. Wierzcho³ek startowy dla algorytmu równie¿ jest wybierany losowo.\\~\\
Algorytm Prima oparty jest o metodê zach³ann¹. Mo¿na opisaæ go nastêpuj¹co:
\begin{enumerate}
\item Rozpoczynamy od grafu sk³adaj¹cego siê jedynie z wierzcho³ka startowego.
\item Krawêdzie incydentne do wierzcho³ka umieszczamy na posortowanej wg. wag liœcie.
\item Zdejmujemy z listy krawêdŸ o najmniejszej wadze i sprawdzamy, czy ³¹czy wierzcho³ek wybrany z niewybranym. Jeœli tak, to znalezion¹ krawêdŸ dodajemy do drzewa spinaj¹cego.
\item Dodajemy krawêdzie incedentne z nowowybranym wierzcho³kiem do posortowanej listy.
\item Powtarzamy kroki 2 - 4 dopóki lista krawêdzi nie bêdzie pusta.
\end{enumerate}

\begin{figure}[H]
\centering
\begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=2cm,
  thick,main node/.style={circle,fill=white!25,draw,minimum size = 8mm}]
  \node[main node] (0) {0};
  \node[main node] (1) [right of=0]{1};
  \node[main node] (2) [right of=1]{2};
  \node[main node] (3) [right of=2]{3};
  \node[main node] (4) [below of=0]{4};
  \node[main node] (5) [right of=4]{5};
  \node[main node] (6) [right of=5]{6};
  \node[main node] (7) [right of=6]{7};
  \node[main node] (8) [below of=4]{8};
  \node[main node] (9) [right of=8]{9};
  \node[main node] (10) [right of=9]{10};
  \node[main node] (11) [right of=10]{11};
  \node[main node] (12) [below of=8]{12};
  \node[main node] (13) [right of=12]{13};
  \node[main node] (14) [right of=13]{14};
  \node[main node] (15) [right of=14]{15};
  \path[every node/.style={font=\sffamily\small}]
     (0) edge node [above] {345} (1)
         edge node [right] {34} (4)
     (1) edge node [above] {21} (2)
         edge node [right] {41} (5)
     (2) edge node [above] {561} (3)
         edge node [right] {329} (6)
     (3) edge node [right] {12} (7)         
     (4) edge node [above] {21} (5)
         edge node [right] {13} (8)
     (5) edge node [above] {563} (6)
         edge node [right] {42} (9)
     (6) edge node [above] {37} (7)
         edge node [right] {212} (10)
     (7) edge node [right] {33} (11)  
     (8) edge node [above] {452} (9)
         edge node [right] {25} (12)
     (9) edge node [above] {439} (10)
         edge node [right] {470} (13)
     (10) edge node [above] {64} (11)
         edge node [right] {30} (14)
     (11) edge node [right] {290} (15)
     (12) edge node [above] {92} (13)
     (13) edge node [above] {23} (14)
     (14) edge node [above] {70} (15);
\end{tikzpicture}
\caption{Graf przejœæ z nadanymi wagami}
\end{figure}

\begin{figure}[H]
\centering
\begin{minipage}{.48\textwidth}
\centering
\begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=2cm,
  thick,main node/.style={circle,fill=white!25,draw,minimum size = 8mm}]
  \node[main node] (0) {0};
  \node[main node] (1) [right of=0]{1};
  \node[main node] (2) [right of=1]{2};
  \node[main node] (3) [right of=2]{3};
  \node[main node] (4) [below of=0]{4};
  \node[main node] (5) [right of=4]{5};
  \node[main node] (6) [right of=5]{6};
  \node[main node] (7) [right of=6]{7};
  \node[main node] (8) [below of=4]{8};
  \node[main node] (9) [right of=8]{9};
  \node[main node] (10) [right of=9]{10};
  \node[main node] (11) [right of=10]{11};
  \node[main node] (12) [below of=8]{12};
  \node[main node] (13) [right of=12]{13};
  \node[main node] (14) [right of=13]{14};
  \node[main node] (15) [right of=14]{15};
  \path[every node/.style={font=\sffamily\small}]
     (0) edge node [right] {34} (4)
     (1) edge node [above] {21} (2)
         edge node [right] {41} (5)
     (3) edge node [right] {12} (7)         
     (4) edge node [above] {21} (5)
         edge node [right] {13} (8)
     (5) edge node [right] {42} (9)
     (6) edge node [above] {37} (7)
     (7) edge node [right] {33} (11)  
     (8) edge node [right] {25} (12)
     (10) edge node [above] {64} (11)
         edge node [right] {30} (14)
     (12) edge node [above] {92} (13)
     (13) edge node [above] {23} (14)
     (14) edge node [above] {70} (15);
\end{tikzpicture}
\caption{Minimalne drzewo spinaj¹ce znalezione przez algorytm Prima}
\label{fig:span}
\end{minipage}\hfill
\begin{minipage}{.48\textwidth}
\centering
\includegraphics[width=\linewidth]{mapa_z_labiryntu.png}
\caption{Mapa, która powsta³a dla tych warunków pocz¹tkowych, wygenerowana przez program The Mighty Marian}
\label{fig:mapfrommaze}
\end{minipage}\hfill
\end{figure}

\subsubsection{Po³o¿enie przejœæ miêdzy pokojami}
W okreœlonym w poprzednim etapie drzewie spinaj¹cym wagi krawêdzi zastêpujemy losowo wartoœciami ze zbioru ${1,4}$. Ta wartoœæ okreœla w którym miejscu pomiêdzy pokojami utworzone zostanie przejœcie. Przejœcie to prostok¹t o szerokoœci $rozmiar pokoju/4$ i d³ugoœci dwóch komórek. Przejœcia s¹ obliczane i umieszczane osobno w ka¿dym pokoju. Dziêki wprowadzeniu ró¿no
\begin{figure}[H]
\centering
\begin{minipage}{.48\textwidth}
\centering
\begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=2cm,
  thick,main node/.style={circle,fill=white!25,draw,minimum size = 8mm}]
  \node[main node] (12) {0};
  \node[main node] (13) [right of=12]{1};
  \node[main node] (14) [right of=13]{2};
  \node[main node] (15) [right of=14]{3};
  \node[main node] (8) [below of=12]{4};
  \node[main node] (9) [right of=8]{5};
  \node[main node] (10) [right of=9]{6};
  \node[main node] (11) [right of=10]{7};
  \node[main node] (4) [below of=8]{8};
  \node[main node] (5) [right of=4]{9};
  \node[main node] (6) [right of=5]{10};
  \node[main node] (7) [right of=6]{11};
  \node[main node] (0) [below of=4]{12};
  \node[main node] (1) [right of=0]{13};
  \node[main node] (2) [right of=1]{14};
  \node[main node] (3) [right of=2]{15};
  \path[every node/.style={font=\sffamily\small}]
     (0) edge node [above] {1} (1)
     (1) edge node [right] {2} (5)
     (2) edge node [above] {1} (3)
     (3) edge node [right] {4} (7)
     (4) edge node [above] {3} (5)
         edge node [right] {4} (8)
     (5) edge node [above] {4} (6)
         edge node [right] {1} (9)
     (6) edge node [above] {2} (7)
     (7) edge node [right] {2} (11)
     (8) edge node [right] {2} (12)
     (9) edge node [above] {2} (10)
     (10) edge node [right] {1} (14)
     (12) edge node [above] {3} (13)
     (14) edge node [above] {3} (15);
\end{tikzpicture}
\caption{Szerokoœæ na jakiej umieszczono przejœcie}
\label{fig:przjescia}
\end{minipage}\hfill
\begin{minipage}{.48\textwidth}
\centering
\includegraphics[width=\linewidth]{przejscia_mapa.png}
\caption{Wp³yw na wygenerowan¹ mapê}
\label{fig:mapfrompassages}
\end{minipage}\hfill
\end{figure}

Ju¿ cztery stopnie ró¿norodnoœci przejœæ tworz¹ wra¿enie róŸnorodnoœci i pomagaj¹ ukryæ przed graczem, to ¿e porusza siê po prostu po labiryncie.
\begin{figure}[H]
\centering
\begin{minipage}{.48\textwidth}
\centering
\includegraphics[width=\linewidth]{tesame.png}
\caption{Przyk³adowa mapa, w której przejœcia umieszczone s¹ na tej samej szerokoœci}
\label{fig:tesame}
\end{minipage}\hfill
\begin{minipage}{.48\textwidth}
\centering
\includegraphics[width=\linewidth]{rozne.png}
\caption{Przyk³adowa mapa w której przejœcia pojawiaj¹ siê w ró¿nych szerkoœciach}
\label{fig:rozne}
\end{minipage}\hfill
\end{figure}

\subsubsection{Etap pokoju}
\subsubsection{Etap ³¹czenia i wyg³adzania}
\subsubsection{Etap erozji}
Poniewa¿ szerokoœæ bohatera jest wiêksza ni¿ szerokoœæ jednej kómórki i koliduje on z przestrzeni¹
\subsubsection{Efekt koñcowy}


\subsection{Rozmieszczenie gracza i wrogów}
\subsubsection{Wyznaczenie pocz¹tku i koñca poziomu}
\subsubsection{Najkrótsza cie¿ka przejœcia i jej konsekwenjce}
\subsubsection{Po³o¿enie pocz¹tkowe gracza}
\subsubsection{Pozycje pocz¹tkowe wrogów}
\subsubsection{Wyznaczenie pozycji handlarza}
\subsubsection{Efekt koñcowy}
%\centerline{\includegraphics{loll.png}}

\end{document}